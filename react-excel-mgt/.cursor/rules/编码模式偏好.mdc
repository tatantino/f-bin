---
description: 编码模式偏好
globs: ["**/*.tsx", "**/*.ts", "**/*.jsx", "**/*.js", "**/*.scss", "**/*.css"]
---

# 编码模式偏好

## 代码设计原则

- **简洁至上**：始终倾向于简单的解决方案，避免过度设计
- **DRY原则**：尽可能避免代码重复，检查代码库中是否已存在类似功能
- **单一职责**：每个组件、函数和模块应只负责一个明确的功能
- **可测试性**：编写便于测试的代码，避免复杂的依赖关系
- **渐进式改进**：优先考虑改进现有实现，而非引入全新模式
- **函数式优先**：推荐使用函数组件和声明式编程
- **模块化结构**：按功能组织文件结构：导出组件、子组件、辅助函数、静态内容、类型定义

## 代码风格与命名规范

### 代码质量标准
- **代码整洁**：保持代码库整洁且有条理，遵循一致的格式规范
- **文件大小**：单个文件代码行数不应超过200-300行，达到此限制时进行拆分重构
- **注释适度**：代码应当自解释，仅在必要时添加注释说明复杂逻辑
- **类型安全**：充分利用TypeScript类型系统，避免any类型的滥用
- **简洁语法**：
  - 使用"function"关键字定义纯函数
  - 简单条件语句避免不必要的大括号
  - 使用声明式JSX

### 命名规范
- **目录命名**：全部小写，使用短横线分隔（如 `components/auth-wizard`）
- **组件文件**：使用PascalCase（如 `DataTable.tsx`）
- **工具文件**：使用camelCase（如 `dateUtils.ts`）
- **导出方式**：统一采用命名导出
- **变量命名**：使用描述性名称，辅助动词（如 `isLoading`, `hasError`）
- **类型定义**：优先使用 `interface`，避免滥用 `type` 和 `enum`

## TypeScript 使用标准

- **严格模式**：开启严格模式，所有函数必须明确声明返回类型
- **错误处理**：仅在必要层级使用try/catch捕获异常，保证错误处理清晰
- **类型定义**：
  - 优先使用interface，保持类型定义的一致性
  - 避免使用enum，优先使用map对象
  - 使用TypeScript接口定义函数组件
- **避免any**：禁止滥用any类型，必要时使用unknown或明确的类型

## React与Next.js最佳实践

- **Hooks使用**：正确使用React Hooks，遵循Hook规则
- **状态提升**：适当提升共享状态，禁止使用useContext，复杂情况可以使用已经安装好的zustand
- **避免副作用**：减少组件中的副作用，确保组件行为可预测
- **性能优化**：
  - 避免无限循环：谨慎处理useEffect依赖数组
  - 利用Suspense边界平滑处理数据加载
  - 定期进行代码审查，避免不必要重渲染
- **Next.js特性使用**：
  - 使用Suspense包装客户端组件并提供fallback
  - 非关键组件使用动态加载

## UI 与样式规范

- **技术选型**：
  - 使用Shadcn UI结合Tailwind CSS构建组件
  - 通过Framer Motion实现关键动画效果
- **组件文档**：为每个新增组件提供安装说明、使用文档及接口参考
- **组件管理**：
  - 共享纯展示组件存于 `/components/shared`
  - 共享逻辑组件存于 `/hooks/`
  - 共享组件需要添加使用示例

## 项目规范

- **环境配置**：未经询问和确认，绝不覆盖.env文件
- **依赖管理**：谨慎添加新依赖，优先使用项目已有的库和工具
- **API设计**：设计清晰、一致且易于使用的API接口
- **错误处理**：实现全面的错误处理机制，避免未捕获的异常
- **状态管理**：合理组织应用状态，避免状态管理过度复杂化

## 文档规范

- **语言规则**：
  - 所有代码和页面内容必须使用英文
  - 注释和项目文档可结合中文，确保全团队易懂
- **文档要求**：
  - README文件：提供清晰的项目设置和使用说明
  - API文档：记录接口交互和数据流
  - 组件文档：说明组件接口、用法和约束
- **注释原则**：仅在逻辑复杂处添加注释，避免过多冗余注释

## 开发实践

- **谨慎修改**：只进行所要求的更改，或确保所做更改与需求直接相关
- **渐进式重构**：在修复问题时，先尝试现有实现的所有选项，再考虑引入新模式
- **删除冗余**：引入新实现后，确保删除旧的实现方式，避免重复逻辑
- **优先使用工具库中的工具**： 相较于自己实现工具函数，优先使用比如Lodash等工具库中的工具